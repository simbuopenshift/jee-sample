In that case, you can use a subquery to first aggregate the "parameter" array, and then use the result in the outer query to construct the XML. Here's an updated query:

```
SELECT 
  CONCAT(
    '<headers>',
    CASE 
      WHEN data IS NOT NULL THEN 
        STRING_AGG(
          CONCAT(
            '<Qual id="', JSON_EXTRACT_SCALAR(input, '$.qualifierId'), '">',
            IFNULL(
              (SELECT STRING_AGG(CONCAT(
                '<param',
                IFNULL(CONCAT(' value="', JSON_EXTRACT_SCALAR(param, '$.value'), '"'), ''),
                IFNULL(CONCAT(' uom="', JSON_EXTRACT_SCALAR(param, '$.uom'), '"'), ''),
                IFNULL(CONCAT(' altValue="', JSON_EXTRACT_SCALAR(param, '$.altValue'), '"'), ''),
                IFNULL(CONCAT(' altUom="', JSON_EXTRACT_SCALAR(param, '$.altUom'), '"'), ''),
                '/>'
              )) FROM UNNEST(JSON_EXTRACT_ARRAY(input, '$.parameter')) param),
              ''),
            '<text>', JSON_EXTRACT_SCALAR(input, '$.text'), '</text>',
            '</Qual>'
          ),
          ''
        )
      ELSE ' ' 
    END,
    '</headers>'
  ) AS detail
FROM 
  table;
```

This query uses a subquery to aggregate the "parameter" array, and then uses the result in the outer query to construct the XML. The subquery uses `UNNEST` to expand the "parameter" array, and then uses `STRING_AGG` to concatenate the "param" elements.
